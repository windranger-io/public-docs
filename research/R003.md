# Guidance: Tokens

_from [Cooper Midroni](https://twitter.com/midroni) of_ [_`Windranger Labs`_](https://windranger.io/)

# Introduction

Beginning narrative written by Cooper

- Cryptokens have always been a major part of the blockchain/web3 narrative, no doubt owing to the fact that the first successful blockchain use case - Bitcoin - was itself a token.

- The story surrounding tokens has shifted over the years.

- It was really during the 2017 ICE craze that tokens began to take center stage. Enabled by widespread adoption of the ERC-20 token standard.

- The original metaphor for tokens was that they allowed any project to simulate an 'IPO'-style fundraise, in which anyone could buy tokens at OTC prices. Amongst the more optimistic takes was that this fundraising approach would projects to raise capital from their user base with the added benefits of implicating a project's community in its financial success.

- As time would tell, a lack of diligence on projects and their founding teams lead to massive loss of capital. Users without an understanding of exchange mechanics found themselves unable to sell in too-shallow markets.

- And the 2017 bull cycle was laid to rest.

- In the more recent upswing, tokens evolved in their meaning.

- about a project's spec sheet -

- Tokens became about more than financial stake, and instead about access, authorization, collectivization.

- At their core, tokens still represented a piece of the upside... but users began to understand that tokens were not just a digital analog to shares. Instead, they were recognized as a universally programmable digital asset. Like all software, functionality and possibilities were only limited by imagination

- Wisened from their 2017 losses, consumers began to care more about a project's 'spec sheet' - how many tokens do they plan to issue and on what schedule? Who can control the token smart contract? How will my ownership be recognized in governance?

- The term tokenomics increased in popularity, and in turn became a specialization that teams specifically hired for.

- Many projects from 2017-era that survived now realized flaws in their early tokenomic design. Teams had to adapt from early miscalculations on their token emissions.

- Whereas 2017 was defined by a rush to tokenization, 2021 brought about a collective hesitancy. We understood tokens for their full potential, and in doing so can now take the precautionary measures to launch tokens properly

- This guide is meant as a handbook. Refer to it whenever the need arises. In it we explain the many dimensions and capabilities of tokens, namely through the ERC-20 contract, in hopes that we can help the community make more informed decisions about token designs and their tradeoffs.

Thank the team that worked on it. Thank the reviewers...

## Function x Token Table

Something here about how we performed an analysis of functions employed by different tokens. In order to maintain reasonable scope, we selected the most relevant functions. For functions not discussed here, we refer you to either Ethereum or OpenZeppelin documentation.

|       Functions       |  BIT   | Comp | Uni | Curve | Aave | USDC |  G7   |
| :-------------------: | :----: | :--: | :-: | :---: | :--: | :--: | :---: |
|     **Transfer**      |        |      |     |       |      |      |       |
|        Approve        |   Y    |  Y   |  Y  |   Y   |  Y   |  Y   | Must  |
|       Transfer        |   Y    |  Y   |  Y  |   Y   |  Y   |      | Must  |
|     TransferFrom      |   Y    |  Y   |  Y  |   Y   |  Y   |      | Must  |
|  Increase Allowance   |   Y    |      |     |       |  Y   |  Y   | Must? |
|  Decrease Allowance   |   Y    |      |     |       |  Y   |  Y   | Must? |
|        Permit         |        |      |  Y  |       |      |  Y   |       |
|      **Balance**      |        |      |     |       |      |      |       |
|       Snapshot        |   Y    |      |     |       |      |      |       |
|     totalSupplyAt     |        |      |     |       |      |      |       |
|      balanceOfAt      |        |      |     |       |      |      |       |
|    **Governance**     |        |      |     |       |      |      |       |
|       Delegate        |   Y    |  Y   |  Y  |       |  Y   |      | Must  |
|     DelegateBySig     |   Y    |  Y   |  Y  |       |  Y   |      | Must  |
|    DelegatebyType     |        |      |     |       |  Y   |      | Maybe |
|  DelegatebyTypebySig  |        |      |     |       |  Y   |      | Maybe |
|   **Token Supply**    |        |      |     |       |      |      |       |
|         Mint          |        |      |  Y  |   Y   |      |  Y   | Maybe |
|       setMinter       |        |      |  Y  |       |      |      |       |
|         Burn          | Regret |      |     |   Y   |      |  Y   | Maybe |
|     **Security**      |        |      |     |       |      |      |       |
|       Blacklist       |        |      |     |       |      |  Y   |   Y   |
|         Pause         |        |      |     |       |      |  Y   |   Y   |
|        Rescue         |        |      |     |       |      |  Y   |   Y   |
|  **Access Control**   |        |      |     |       |      |      |       |
|      acceptAdmin      |   Y    |      |     |       |      |      |   ?   |
|    setPendingAdmin    |   Y    |      |     |       |      |      |   ?   |
|   **Upgradability**   |        |      |     |       |      |      |       |
| Upgradability (Proxy) |        |      |     |       |  Y   |  Y   | Maybe |
|      Initialize       |        |      |     |       |  Y   |  Y   |       |

# Token Functions & Interfaces

Key to making informed decisions on token design is understanding what tokens exactly are.

A token is a smart contract with a standard interface. Standardizing a token's interface allows for tokens to be arbitrarily compatible in applications such as wallets, DEXes, and more. The interface defines variables and methods that allow this particular object to behave and have properties of a token. For instance, a token should have a certain supply, be tradable, and be owned by different users/accounts . And indeed we see that the ERC 20 contract is implemented with variables and methods for `totalSupply()`, `transfer()` and `allowance()` which tracks balances for different owners.

# Token Functions

These functions are implementations of the interfaces:

- [ERC 20 Token Standard](https://eips.ethereum.org/EIPS/eip-20)

- [ERC 20 Custom Extensions](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#ERC20)

- [ERC 20 Permit Extension](https://eips.ethereum.org/EIPS/eip-2612)

- [Proxy Upgrade Pattern](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)

## Transfer & Balance Functions

The ERC-20 contract enables two different token transferring scenarios. The first scenario allows you to transfer tokens using your own account. The second scenario allows you to authorize a third party (typically another account/smart contract) to transfer tokens on your behalf. These scenarios are enabled by the following methods. In the following sections:

- Scenario 1: Self-Transfer

  - transfer

- Scenario 2: Authorized Party Transfer

  - approve

  - transferFrom

  - increaseAllowance

  - decreaseAllowance

### transfer (address \_to, uint256 \_value)

[ERC-20]

Primary Use Case: Used to transfer tokens from owned by your account to a target recipient.

Scenario: Alice calls `transfer()` to send her own tokens to a target recipient, Bob.

Requirements:

- The account owner must have the required funds to transfer. Check whether account balance is more than the amount being transferred.

- The recipient account must not be the 'Null address'; 0 address. 0x0000000... which is used to burn tokens.

Advantages:

- If the function call fails, the transfer function will return to its previous state. This means that in the event of failure, only gas fees are lost.

- This function is an effective guard against re-entrancy attacks. It forwards only 2300 gas for contract execution, which is not sufficient for the recipient address/contract to once again call the contract.

### approve (address \_spender, uint25 \_value)

[ERC-20]

Primary Use Case: Used to authorize another account (spender) to transfer funds from your account's balance. The approve method sets an approved token amount (allowance) on the tokens that a spender can transfer out of your account.

Scenario: Alice calls `approve()` authorizes Bob to transfer up to 10 tokens from her account.

Requirements:

- The account owner's token balance must be greater than the allowance.

- The spender being approved cannot be the null address.

(amount) of tokens a given account may transfer out of your account. It binds the approval to the msg.sender, which implies that the approve function has a transaction explicitly initiated by an externally owned account (EOA).

### transferFrom (address \_from, address \_to, uint256 \_value)

[ERC-20]

Primary Use Case: Used by a 3rd-party to transfer funds owned by another account to any recipient account, up to their authorized allowance.

Scenario: Bob calls `transferFrom("0xAlice", "0xCarla", 10)` on a token's smart contract in an attempt to send 10 of Alice's tokens to Carla.

Requirements:

- The allowance of the calling account (eg. Bob) must be greater than the amount to transfer.

- The calling account must be approved to spend the amount.

#### Challenge #1: Approval Front-Running: 

Attack Vectors :

- Approval front-running : Results in more than intended tokens being approved for a given address. Scenario as below :

1.  Alice allows Bob to transfer 100 BIT by calling `approve` on the token's smart contract. These details are passed in as method arguments: approve("0xBob", 100);

2.  After some time, Alice decides to change Bob's approved allowance from 100 BIT to 10 BIT.  Alice calls `approve` again, now passing the following arguments: approve("0xBob", 10);

3.  Bob notices Alice's second transaction before it was mined and quickly sends another transaction, using the transferFrom method to transfer 100 BIT to himself: transferFrom("0xAlice", "0xBob", 100);

4.  If Bob's transaction is executed before Alice's transaction, Bob will successfully transfer 100 BIT and gain the ability to transfer yet another 10 tokens. This happens as Bob can include higher transaction fees than Alice, leading to Bob's transaction being confirmed earlier.

5.  Before Alice notices that something went wrong, Bob calls transferFrom method again, this time to transfer 10 further BIT. This results in Bob acquiring 110 of Alice's tokens instead of only 10.

So how can we solve this problem? To solve this we must bring in non-standard methods popularized in OpenZeppelin's IERC20 interface.

### increaseAllowance (address spender, uint256 addedValue)

Primary Use Case: allows an account to increase a spender's allowance while avoiding a front-running attack

Scenario:

Requirements:

- Spender cannot be the zero address

### decreaseAllowance (address spender, uint256 subtractedValue)

Primary Use Case: allows an account to decrease a spender's allowance while avoiding a front-running attack

Scenario:

Requirements:

- Spender cannot be the zero address

- Spender must have allowance for the caller of at least subtractedValue

Thus our solution to the problem would be:

Solution : Use increaseAllowance and decreaseAllowance functions to approve allowances.

Increase Allowance : Increases the allowance (amount) of tokens that a given account may transfer from your account.

Decrease Allowance : Decreases the allowance (amount) of tokens that a given account may transfer from your account.

The difference between approve(spender, amount) and increaseAllowance(spender, addedValue) and decreaseAllowance(spender, subtractedValue) is that instead of passing absolute values to be approved to an address, the value to be added or subtracted is passed to the function and the allowance value is updated using the add() and sub() methods. Code as follows :

\_allowances[\_msgsender()][spender].add(addedValue)

Or \_allowances[\_msgsender()][spender].sub(subtractedValue)

#### Challenge #2: Approve Msg.Sender Dependency

It's fair to say that the approve and transferFrom methods are precisely what enabled ERC-20 tokens to become so deeply embedded across Ethereum's dapps. Providing contracts with an allowance of tokens creates a feeling of effortless integration and interoperability throughout the ecosystem. However, this system still has its limitations. For instance, approve must always be called by the account owner (AKA msg.sender), which imposes a gas requirement on the owner and splits the user experience across two transactions (one for calling approve and another for the contract call to transferFrom).

![](https://lh6.googleusercontent.com/x4R61k_4NhyGhCy-93zuhPIcDGA1rOgez2eRI9L9Hrd4F6QRbujRmtBbAXdJlI9xSlNa7JVVz4RIksQfAY0vYGAmnvoznnWt6k7Q6J7uyCDbwxCNcuDRTo6yQVhpOvSGlfKHbhz-eaE3jsI0nZKAvt6vnaNrU0j80QjCLkPfKjv1GjaTJaJFZuP5EA)

However, a solution to this dilemma was created in EIP-2612, which added a new function; permit. This new solution takes advantage of Ethereum meta-transactions.

As every address on Ethereum has a private/public key, it should suffice that a user can send a signed message using their private key to approve a transaction. This abstraction allows a user to submit both their signature and a transaction to a 3rd-party known as a relayer. Relayers submit the user's transaction to the network, covering gas costs while typically accepting a fee from tokens used within the transaction. For instance, a relayer could execute a DAI-USDT token swap while accepting fees in DAI. The development of meta-transactions can only be leveraged through the use of permit.

![](https://lh6.googleusercontent.com/z8sY6CtdOijDttte65bJExmbcMyW6TlEjgzSlF-6r6Fju7f-8AjECz6IK9ncrHgo_yDq64WluVlXcUAdJiKcvDAQrfJAq7_xJXdTJwYNmlxDsbskAQvn_rQbm3uozDW4sL0G5xOYfsBj5LmKwIoFhoa28GePx19uV9EjY7i2geXxF7Xl9TJ9pbuz2Q)

### permit (address owner, address spender, ...)

Primary Use Case: Allows users to modify the token allowance of a 3rd-party contract through the use of signed messages (meta-transactions).

Scenario: Uniswap V2 pools now support meta-transaction approvals via the permit method. Alice sends her DAI-USDT token swap transaction along with a signed message to a relayer. The relayer submits this transaction to the network, taking a small amount of Alice's DAI to cover gas costs.

Requirements:

- The permit function has a complex set of requirements which have already been well documented. We encourage you to look at [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612) for more details.

Advantages:

1.  Allows any operation involving an ERC-20 token to be paid for using the token itself, instead of relying on ETH

2.  Reduces total number of transactions.

## Balance Functions

The methods we've described so far allow for a fairly functional token - one that can be traded by its owner and an approved list of contracts that is managed by the owner.

Say you wanted to implement a mechanism like weighted voting, or a lottery amongst token holders for an airdrop. These would require some ability to access the current state of the token and its holders across the entire chain.

### \_snapshot()

Primary Use Case: Create a snapshot of the token and its balance across accounts.

Scenario: As the creator of BIT, Alice wants to understand who the major holders of her token are and how they change over time. Every day she calls \_snapshot() to preserve an image of accounts holding her token and their balances over time.

Requirements:

- \_snapshot is an internal function. As the contract creator you can decide how and if to expose it externally. For more on this, see our section on Access & Control.

Advantages:

- ERC20 with a snapshot mechanism

- Snapshot contains the balances and total supply

- Can be used to create mechanisms based on token balances such as trustless dividends or weighted voting

### totalSupplyAt()

Primary Use Case: Get the total supply of a token at the time of a snapshot.

Scenario: Alice wants to manage her project's token emissions. She enters each day's snapshot ID into totalSupplyAt() to receive the total number of tokens in circulation. Tracking this each day will allow her to measure token issuance over time.

Requirements:

Advantages:

### balanceOfAt()

Primary Use Case: Get the balance of an account at the time of a snapshot.

Scenario: Alice wants to monitor the token supply held by certain partners and whales in her ecosystem. Using balanceOfAt() she can enter their addresses and each day's snapshot ID to track their individual changes in balance.

Requirements:

Advantages:

## Governance Functions

As mentioned, balance and snapshot methods can be used to layer functionality on top of your token. They are essential to being able to engage and activate with your token holder base, namely by knowing their addresses and relative ownership. This information is the foundation for one of the most promising use cases of crypto-tokens; decentralized voting and governance.

By governance, we mean the practice of using tokens to arrive at some form of consensus on decision making. Many projects enable their communities to self-govern with a simple 'one-token-one-vote' model applied to a forum making yes/no decisions. Platforms like [Snapshot](https://snapshot.org/#/) help surface community proposals for voting and keeping a historic record of the outcome.

There are many challenges with governance, the most likely of which to encounter is asymmetry in token distribution. The nature of tokenized projects is often that the vast majority of tokens are held by a core team or foundation. It takes most projects several years to enact a roadmap of progressive decentralization; during which they issue more of the token to engaged users and stakeholders in the project.

In the meantime, it is still important to engage the community through governance, and activate them with meaningful voting power so they can help steer the project. To this effect, we have adopted the concept of delegation. Delegation allows voting power to be allocated to select groups or individuals, without conferring underlying ownership of the token. Effective delegation requires that three scenarios be enabled:

### Delegate

Primary Use Case:

Scenario:

Requirements:

Advantages: Hint for author: Security of voting wallet -  that delegation does not lock or transfer tokens. If an isolated delegatee wallet is stolen, compromised, or interacts with the incorrect smart contract, this will not directly result in the loss of BIT tokens, and the BIT holder can delegate to another address.

Primary usage : Used to delegate votes from the sender (user having delegate power) to the delegatee. The token holder sends their delegate choice directly to the contract, which in turn updates the delegate mapping.

### DelegateBySig

Primary Use Case:

Scenario:

Requirements:

Advantages:

Primary usage : Similar to delegate function, also used to delegate votes from the signatory (user having voting power) to the delegatee. But, similar to the 'permit' function discussed above, it enables offline signatures (signed message) to delegate the votes. Offline signature creation process : [EIP712](https://eips.ethereum.org/EIPS/eip-712)

Advantage :

1.  Allows for off-chain delegation, i.e. , the user need not perform an explicit transaction to delegate his votes. Saves gas cost.

1.  The delegation is sent by another on behalf of the holder. Creates an opportunity to delegate power through a third party (similar to transferFrom function) for a single proposal (instead of indefinite delegation. [Implementation example](https://medium.com/compound-finance/delegation-and-voting-with-eip-712-signatures-a636c9dfec5e)

### DelegatebyType

Primary Use Case:

Scenario:

Requirements:

Advantages:

The token holder sends their delegate for one of their powers (required 2+ purposes of the tokens). Primary usage : Used to delegate specific type of governance power to a specific address. For example, the governance token is primarily used for two actions -

1.  Create proposal (token balance > proposal threshold)

2.  Vote on a proposal

Token holders can delegate their voting power such that the delegatee can only vote with the delegated power but not create proposals.

Advantage : Creates granularity in the governance actions granted to the delegatee. In case of DAO reorganization using working groups, the members of the working group can only be assigned voting and proposal power for certain types of operational decisions. This paves the way for permissioned/controlled delegation for better DAO governance.

AAVE's Implementation : AAVE uses the function for separation of concerns w.r.t governance powers - voting and proposal creation. The function introduces a uint8 parameter for specifying the delegateType function signature as follows :

function delegateByType( address delegatee, uint amount, uint8 delegateType) {---}

AAVE assigns two values to the delegateType parameter -

- 0 = voting right

- 1 = proposal right

If a shareholder delegates voting rights using the function delegateByType as follows :

Function delegateByType(0xb1235fakjd...., 500000, 0){ ---}

Even if the delegatee has voting power > proposalThreshold, the delegatee would not be able to create a proposal. He can only vote on existing proposals using the delegated voting power.

For more complex governance and DAO structures, several uint8 values or more parameters with

Protocol specific values can be implemented to granularise governance power delegation.

### DelegatebyTypebySig

Primary Usage : This is similar to delegateByType, by using the function signatures to perform offchain delegations.

Potential practical Usage : Granular Mass-delegation using signatures - Enables working group driven liquid democracy. Governance power can be delegated for specific type of proposal and for a single proposal (time bound delegation).

## References

[BitDAO Token Functions](https://etherscan.io/address/0x1a4b46696b2bb4794eb3d4c26f1c55f9170fa4c5#writeContract)

[BitDAO Token Audit](https://docs.bitdao.io/additional-documents/audit-reports)

[Compound Token Function](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888#writeContract)

[Uniswap Token Functions](https://etherscan.io/address/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#writeContract)

[Curve Token Functions](https://etherscan.io/address/0xD533a949740bb3306d119CC777fa900bA034cd52#writeContract)

[AAVE Token Functions](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9#writeContract)

[AAVE Token Functions (by Proxy)](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9#writeProxyContract)

[USDC Token Functions](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#writeContract)

[USDC Token Functions (by Proxy)](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#writeProxyContract)
